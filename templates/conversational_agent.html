<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 11: Enhanced Conversational AI with Error Handling | 30 Days Voice Agents</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f7f7f8;
            height: 100vh;
            overflow: hidden;
            color: #333;
        }
        
        .chat-container {
            display: flex;
            height: 100vh;
        }
        
        /* Sidebar Styles */
        .sidebar {
            width: 280px;
            background: #202123;
            border-right: 1px solid #4d4d4f;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .sidebar-header {
            padding: 18px 16px;
            border-bottom: 1px solid #4d4d4f;
        }
        
        .new-chat-btn {
            width: 100%;
            background: #10a37f;
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .new-chat-btn:hover {
            background: #1a7f64;
            transform: translateY(-1px);
        }
        
        .chat-history {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }
        
        .chat-item {
            padding: 12px 16px;
            margin: 4px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            color: #ececf1;
            font-size: 14px;
            border: 1px solid transparent;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .chat-item:hover {
            background: #2a2b32;
        }
        
        .chat-item.active {
            background: #343541;
            border-color: #10a37f;
        }
        
        .chat-title {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-right: 8px;
        }
        
        .sidebar-footer {
            padding: 16px;
            border-top: 1px solid #4d4d4f;
            background: #1a1b1e;
        }
        
        .navigation-links {
            margin-bottom: 12px;
        }
        
        .nav-link-small {
            color: #10a37f;
            text-decoration: none;
            display: block;
            padding: 8px 0;
            font-size: 13px;
        }
        
        .nav-link-small:hover {
            color: #1a7f64;
        }
        
        .user-info {
            color: #ececf1;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Main Chat Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
        }
        
        .chat-header {
            padding: 16px 24px;
            border-bottom: 1px solid #e5e7eb;
            background: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .chat-title-main {
            font-size: 18px;
            font-weight: 600;
            color: #374151;
        }
        
        .chat-info {
            font-size: 12px;
            color: #6b7280;
            margin-top: 4px;
        }
        
        .session-badge {
            background: #10a37f;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            margin-right: 8px;
        }
        
        .message-limit-info {
            background: #fef3c7;
            color: #92400e;
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: 8px;
            font-size: 11px;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }
        
        .message {
            margin-bottom: 24px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }
        
        .message.user {
            flex-direction: row-reverse;
        }
        
        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }
        
        .message.user .message-avatar {
            background: #10a37f;
            color: white;
        }
        
        .message.assistant .message-avatar {
            background: #6366f1;
            color: white;
        }
        
        .message-content {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 16px;
            line-height: 1.5;
        }
        
        .message.user .message-content {
            background: #10a37f;
            color: white;
            border-bottom-right-radius: 4px;
        }
        
        .message.assistant .message-content {
            background: #f3f4f6;
            color: #374151;
            border-bottom-left-radius: 4px;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6b7280;
        }
        
        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }
        
        /* Voice Input Area */
        .voice-input-area {
            padding: 24px;
            border-top: 1px solid #e5e7eb;
            background: white;
        }
        
        .recording-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
        }
        
        .record-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(45deg, #10a37f, #059669);
            color: white;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(16, 163, 127, 0.3);
        }
        
        .record-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(16, 163, 127, 0.4);
        }
        
        .record-button.recording {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .recording-status {
            text-align: center;
            color: #6b7280;
            font-size: 14px;
        }
        
        /* Progress Indicator */
        .progress-indicator {
            padding: 16px 24px;
            background: #f9fafb;
            border-top: 1px solid #e5e7eb;
            display: none;
        }
        
        .progress-steps {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .progress-step {
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 12px;
            background: #e5e7eb;
            color: #6b7280;
            transition: all 0.3s ease;
        }
        
        .progress-step.active {
            background: #3b82f6;
            color: white;
        }
        
        .progress-step.completed {
            background: #10b981;
            color: white;
        }
        
        /* Message Limit Warning */
        .limit-warning {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 12px 16px;
            margin: 16px 24px;
            display: none;
        }
        
        .limit-warning.show {
            display: block;
        }
        
        .limit-warning-text {
            color: #92400e;
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .limit-warning-btn {
            background: #f59e0b;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        /* Error handling styles */
        .error-indicator {
            padding: 12px 16px;
            margin: 16px 24px;
            border-radius: 8px;
            display: none;
            border-left: 4px solid #ef4444;
            background: #fef2f2;
        }
        
        .error-indicator.show {
            display: block;
        }
        
        .error-indicator.warning {
            border-left-color: #f59e0b;
            background: #fffbeb;
        }
        
        .error-indicator.info {
            border-left-color: #3b82f6;
            background: #eff6ff;
        }
        
        .error-text {
            color: #dc2626;
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .error-indicator.warning .error-text {
            color: #d97706;
        }
        
        .error-indicator.info .error-text {
            color: #2563eb;
        }
        
        .error-details {
            font-size: 12px;
            color: #6b7280;
            margin-top: 4px;
        }
        
        .retry-button {
            background: #ef4444;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 8px;
        }
        
        .retry-button:hover {
            background: #dc2626;
        }
        
        /* Enhanced progress indicator for error states */
        .progress-step.error {
            background: #ef4444;
            color: white;
        }
        
        .progress-step.warning {
            background: #f59e0b;
            color: white;
        }
        
        /* Fallback audio indicator */
        .fallback-audio-indicator {
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 8px 12px;
            margin: 8px 0;
            font-size: 12px;
            color: #6b7280;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .fallback-audio-indicator .icon {
            color: #f59e0b;
        }
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                position: absolute;
                z-index: 1000;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }
            
            .sidebar.open {
                transform: translateX(0);
            }
            
            .main-content {
                width: 100%;
            }
            
            .chat-header {
                padding: 12px 16px;
            }
            
            .chat-messages {
                padding: 16px;
            }
            
            .voice-input-area {
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <button class="new-chat-btn" onclick="startNewChat()">
                    <span>‚ûï</span>
                    New Conversation
                </button>
            </div>
            
            <div class="chat-history" id="chatHistory">
                <div style="text-align: center; color: #6b7280; padding: 20px; font-size: 14px;">
                    <div class="loading-dots" style="display: flex; justify-content: center; gap: 4px; margin-bottom: 8px;">
                        <div class="loading-dot" style="width: 6px; height: 6px; border-radius: 50%; background: #6b7280; animation: bounce 1.4s ease-in-out infinite;"></div>
                        <div class="loading-dot" style="width: 6px; height: 6px; border-radius: 50%; background: #6b7280; animation: bounce 1.4s ease-in-out infinite 0.16s;"></div>
                        <div class="loading-dot" style="width: 6px; height: 6px; border-radius: 50%; background: #6b7280; animation: bounce 1.4s ease-in-out infinite 0.32s;"></div>
                    </div>
                    <div style="margin-top: 8px;">Loading conversations...</div>
                </div>
            </div>
            
            <div class="sidebar-footer">
                <div class="navigation-links">
                    <a href="/" class="nav-link-small">üè† Home</a>
                    <a href="/voice-pipeline" class="nav-link-small">üéôÔ∏è Voice Pipeline</a>
                </div>
                <div class="user-info">
                    <span>ü§ñ</span>
                    <span>Conversational AI</span>
                </div>
            </div>
        </div>
        
        <!-- Main Chat Area -->
        <div class="main-content">
            <div class="chat-header">
                <div style="display: flex; align-items: center; gap: 12px;">
                    <button class="sidebar-toggle" onclick="toggleSidebar()" style="display: none; background: none; border: 1px solid #e5e7eb; padding: 8px 12px; border-radius: 6px; cursor: pointer;">‚ò∞</button>
                    <div>
                        <div class="chat-title-main" id="chatTitle">New Conversation</div>
                        <div class="chat-info">
                            <span class="session-badge" id="sessionBadge">Loading...</span>
                            <span id="messageCount">0 messages</span>
                            <span class="message-limit-info" id="limitInfo">15 remaining</span>
                        </div>
                    </div>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button onclick="clearCurrentChat()" style="background: none; border: 1px solid #e5e7eb; padding: 8px 16px; border-radius: 6px; cursor: pointer; color: #6b7280;">
                        üóëÔ∏è Clear
                    </button>
                    <button onclick="testDisplay()" style="background: none; border: 1px solid #e5e7eb; padding: 8px 16px; border-radius: 6px; cursor: pointer; color: #6b7280;">
                        üß™ Test
                    </button>
                    <button onclick="testErrorHandling()" style="background: none; border: 1px solid #f59e0b; padding: 8px 16px; border-radius: 6px; cursor: pointer; color: #f59e0b;">
                        ‚ö†Ô∏è Test Errors
                    </button>
                </div>
            </div>
            
            <div class="limit-warning" id="limitWarning">
                <div class="limit-warning-text">You've reached the maximum number of messages (15) for this conversation.</div>
                <button class="limit-warning-btn" onclick="startNewChat()">Start New Conversation</button>
            </div>
            
            <div class="error-indicator" id="errorIndicator">
                <div class="error-text" id="errorText">An error occurred</div>
                <div class="error-details" id="errorDetails">Error details will appear here</div>
                <button class="retry-button" id="retryButton" onclick="retryLastAction()" style="display: none;">Retry</button>
            </div>
            
            <div class="chat-messages" id="chatMessages">
                <div class="empty-state" id="emptyState">
                    <div class="empty-state-icon">ü§ñ</div>
                    <h3>Start Your Conversation</h3>
                    <p>Click the microphone button below to begin talking with the AI. Your conversation history will be automatically saved in the sidebar.</p>
                </div>
            </div>
            
            <div class="progress-indicator" id="progressIndicator">
                <div class="progress-steps">
                    <div class="progress-step" id="step1">üéôÔ∏è Recording</div>
                    <div class="progress-step" id="step2">üìù Transcribing</div>
                    <div class="progress-step" id="step3">üß† AI Thinking</div>
                    <div class="progress-step" id="step4">üîä Generating Voice</div>
                </div>
            </div>
            
            <div class="voice-input-area">
                <div class="recording-section">
                    <button id="recordButton" class="record-button" onclick="toggleRecording()">
                        üéôÔ∏è
                    </button>
                    <div class="recording-status" id="recordingStatus">
                        Click to start talking
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentSessionId = null;
        let isRecording = false;
        let mediaRecorder = null;
        let audioChunks = [];
        let conversationHistory = [];
        let currentAudio = null;
        let messageCount = 0;
        const maxMessages = 15;
        let lastFailedAction = null; // For retry functionality
        let errorRetryCount = 0;
        const maxRetries = 3;
        
        // Enhanced error handling functions
        function showError(message, details = '', type = 'error', showRetry = false) {
            console.error('Error:', message, details);
            
            const errorIndicator = document.getElementById('errorIndicator');
            const errorText = document.getElementById('errorText');
            const errorDetails = document.getElementById('errorDetails');
            const retryButton = document.getElementById('retryButton');
            
            errorText.textContent = message;
            errorDetails.textContent = details;
            
            // Set error type styling
            errorIndicator.className = `error-indicator show ${type}`;
            
            // Show/hide retry button
            retryButton.style.display = showRetry ? 'block' : 'none';
            
            // Auto-hide after 10 seconds for non-critical errors
            if (type !== 'error') {
                setTimeout(() => {
                    hideError();
                }, 10000);
            }
        }
        
        function hideError() {
            const errorIndicator = document.getElementById('errorIndicator');
            errorIndicator.classList.remove('show');
        }
        
        function retryLastAction() {
            if (lastFailedAction && errorRetryCount < maxRetries) {
                errorRetryCount++;
                console.log(`Retrying action (attempt ${errorRetryCount}/${maxRetries})`);
                hideError();
                lastFailedAction();
            } else {
                showError(
                    'Maximum retry attempts reached',
                    'Please try recording a new message',
                    'warning'
                );
            }
        }
        
        function handleApiError(error, context = '') {
            console.error(`API Error in ${context}:`, error);
            
            let errorMessage = 'Something went wrong';
            let errorDetails = '';
            let showRetryButton = true;
            
            if (error.message) {
                if (error.message.includes('network') || error.message.includes('fetch')) {
                    errorMessage = 'Network connection issue';
                    errorDetails = 'Please check your internet connection and try again';
                } else if (error.message.includes('timeout')) {
                    errorMessage = 'Request timed out';
                    errorDetails = 'The server is taking too long to respond. Please try with a shorter message';
                } else if (error.message.includes('401') || error.message.includes('403')) {
                    errorMessage = 'Authentication error';
                    errorDetails = 'The service is temporarily unavailable. Please try again later';
                    showRetryButton = false;
                } else if (error.message.includes('429')) {
                    errorMessage = 'Too many requests';
                    errorDetails = 'Please wait a moment before trying again';
                } else if (error.message.includes('500')) {
                    errorMessage = 'Server error';
                    errorDetails = 'The server encountered an error. This has been logged for investigation';
                } else {
                    errorMessage = 'Unexpected error occurred';
                    errorDetails = error.message.substring(0, 100) + (error.message.length > 100 ? '...' : '');
                }
            }
            
            showError(errorMessage, errorDetails, 'error', showRetryButton);
            return false;
        }
        
        function processApiResponse(result, context = '') {
            if (!result) {
                handleApiError(new Error('Empty response received'), context);
                return false;
            }
            
            // Check for fallback indicators
            if (result.is_fallback || result.error_context || result.pipeline_status === 'partial_fallback') {
                let warningMessage = 'Using backup systems';
                let warningDetails = '';
                
                if (result.error_context) {
                    warningDetails = `Some services experienced issues: ${result.error_context}`;
                } else {
                    warningDetails = 'The system automatically switched to backup services to ensure continued operation';
                }
                
                showError(warningMessage, warningDetails, 'warning', false);
            }
            
            // Check for error simulation
            if (result.error_simulation) {
                showError(
                    'Error simulation active',
                    `Testing ${result.simulated_error} error handling - fallback systems engaged`,
                    'info',
                    false
                );
            }
            
            return true;
        }
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing app');
            generateSessionId();
            console.log('Session ID generated:', currentSessionId);
            loadConversationHistory();
            console.log('Conversation history loaded');
            updateMessageLimit();
            console.log('Message limit updated');
            
            // Test display function
            setTimeout(() => {
                console.log('Testing displayConversation function');
                displayConversation();
            }, 1000);
        });
        
        function generateSessionId() {
            currentSessionId = 'conv_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            document.getElementById('sessionBadge').textContent = currentSessionId;
            document.getElementById('chatTitle').textContent = 'New Conversation';
        }
        
        function loadConversationHistory() {
            const history = localStorage.getItem('chatHistory') || '[]';
            const chats = JSON.parse(history);
            const historyContainer = document.getElementById('chatHistory');
            
            if (chats.length === 0) {
                historyContainer.innerHTML = `
                    <div style="text-align: center; color: #6b7280; padding: 20px; font-size: 14px;">
                        No conversations yet. Start your first chat!
                    </div>
                `;
                return;
            }
            
            historyContainer.innerHTML = '';
            chats.slice(-10).reverse().forEach(chat => {
                const chatItem = document.createElement('div');
                chatItem.className = 'chat-item';
                chatItem.onclick = () => loadChat(chat.sessionId);
                
                const title = chat.title || 'Conversation';
                const messageCount = chat.messages ? chat.messages.length : 0;
                
                chatItem.innerHTML = `
                    <div class="chat-title">${title}</div>
                    <div style="font-size: 11px; color: #9ca3af;">${messageCount} msgs</div>
                `;
                
                if (chat.sessionId === currentSessionId) {
                    chatItem.classList.add('active');
                }
                
                historyContainer.appendChild(chatItem);
            });
        }
        
        function startNewChat() {
            if (messageCount >= maxMessages) {
                // Force new chat when limit reached
                generateSessionId();
                conversationHistory = [];
                messageCount = 0;
                document.getElementById('chatMessages').innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">ü§ñ</div>
                        <h3>New Conversation Started</h3>
                        <p>Your previous conversation reached the message limit. Start fresh below!</p>
                    </div>
                `;
                document.getElementById('limitWarning').classList.remove('show');
                updateMessageLimit();
                return;
            }
            
            // Regular new chat
            generateSessionId();
            conversationHistory = [];
            messageCount = 0;
            document.getElementById('chatMessages').innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">ü§ñ</div>
                    <h3>Start Your Conversation</h3>
                    <p>Click the microphone button below to begin talking with the AI.</p>
                </div>
            `;
            document.getElementById('limitWarning').classList.remove('show');
            updateMessageLimit();
            loadConversationHistory();
        }
        
        function loadChat(sessionId) {
            const history = localStorage.getItem('chatHistory') || '[]';
            const chats = JSON.parse(history);
            const chat = chats.find(c => c.sessionId === sessionId);
            
            if (chat) {
                currentSessionId = sessionId;
                conversationHistory = chat.messages || [];
                messageCount = conversationHistory.length;
                document.getElementById('sessionBadge').textContent = sessionId;
                document.getElementById('chatTitle').textContent = chat.title || 'Conversation';
                displayConversation();
                updateMessageLimit();
                loadConversationHistory(); // Refresh to show active state
            }
        }
        
        function updateMessageLimit() {
            const remaining = maxMessages - messageCount;
            const limitInfo = document.getElementById('limitInfo');
            const limitWarning = document.getElementById('limitWarning');
            
            limitInfo.textContent = `${remaining} remaining`;
            
            if (remaining <= 3 && remaining > 0) {
                limitInfo.style.background = '#f59e0b';
                limitInfo.style.color = 'white';
            } else if (remaining <= 0) {
                limitInfo.style.background = '#ef4444';
                limitInfo.style.color = 'white';
                limitInfo.textContent = 'Limit reached';
                limitWarning.classList.add('show');
            } else {
                limitInfo.style.background = '#fef3c7';
                limitInfo.style.color = '#92400e';
            }
            
            document.getElementById('messageCount').textContent = `${messageCount} messages`;
        }
        
        function displayConversation() {
            console.log('displayConversation called, conversationHistory:', conversationHistory);
            const container = document.getElementById('chatMessages');
            console.log('Chat container found:', container);
            
            if (conversationHistory.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">ü§ñ</div>
                        <h3>Start Your Conversation</h3>
                        <p>Click the microphone button below to begin talking with the AI.</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '';
            conversationHistory.forEach(msg => {
                console.log('Adding message to display:', msg);
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${msg.role}`;
                messageDiv.innerHTML = `
                    <div class="message-avatar">${msg.role === 'user' ? 'üë§' : 'ü§ñ'}</div>
                    <div class="message-content">${msg.content}</div>
                `;
                container.appendChild(messageDiv);
            });
            
            container.scrollTop = container.scrollHeight;
            console.log('Conversation display completed');
        }
        
        function saveConversation() {
            const history = localStorage.getItem('chatHistory') || '[]';
            const chats = JSON.parse(history);
            
            const existingIndex = chats.findIndex(c => c.sessionId === currentSessionId);
            const title = conversationHistory.length > 0 ? 
                conversationHistory[0].content.substring(0, 30) + '...' : 
                'New Conversation';
            
            const chatData = {
                sessionId: currentSessionId,
                title: title,
                messages: conversationHistory,
                timestamp: new Date().toISOString()
            };
            
            if (existingIndex >= 0) {
                chats[existingIndex] = chatData;
            } else {
                chats.push(chatData);
            }
            
            // Keep only last 20 conversations
            if (chats.length > 20) {
                chats.splice(0, chats.length - 20);
            }
            
            localStorage.setItem('chatHistory', JSON.stringify(chats));
            loadConversationHistory();
        }
        
        function clearCurrentChat() {
            if (confirm('Are you sure you want to clear this conversation?')) {
                conversationHistory = [];
                messageCount = 0;
                displayConversation();
                updateMessageLimit();
                document.getElementById('limitWarning').classList.remove('show');
                
                // Remove from localStorage
                const history = localStorage.getItem('chatHistory') || '[]';
                const chats = JSON.parse(history);
                const filteredChats = chats.filter(c => c.sessionId !== currentSessionId);
                localStorage.setItem('chatHistory', JSON.stringify(filteredChats));
                loadConversationHistory();
            }
        }
        
        async function toggleRecording() {
            console.log('toggleRecording called, messageCount:', messageCount, 'maxMessages:', maxMessages);
            
            if (messageCount >= maxMessages) {
                alert('Conversation limit reached! Please start a new conversation.');
                return;
            }
            
            if (isRecording) {
                console.log('Stopping recording');
                stopRecording();
            } else {
                console.log('Starting recording');
                startRecording();
            }
        }
        
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };
                
                mediaRecorder.onstop = handleRecordingComplete;
                
                mediaRecorder.start();
                isRecording = true;
                
                document.getElementById('recordButton').classList.add('recording');
                document.getElementById('recordingStatus').textContent = 'üî¥ Recording... Click to stop';
                
            } catch (error) {
                console.error('Error accessing microphone:', error);
                alert('Could not access microphone. Please check permissions.');
            }
        }
        
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                isRecording = false;
                
                document.getElementById('recordButton').classList.remove('recording');
                document.getElementById('recordingStatus').textContent = 'Processing...';
            }
        }
        
        async function handleRecordingComplete() {
            console.log('handleRecordingComplete called');
            const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
            console.log('Audio blob created, size:', audioBlob.size);
            
            // Store this action for potential retry
            lastFailedAction = () => handleRecordingComplete();
            errorRetryCount = 0;
            
            // Show progress and start with recording step
            showProgress();
            updateProgress(1, 'active');
            hideError(); // Clear any previous errors
            
            try {
                const formData = new FormData();
                formData.append('audio_file', audioBlob, 'recording.wav');
                formData.append('session_id', currentSessionId);
                
                // Small delay to show recording step
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Move to transcribing step
                updateProgress(1, 'completed');
                updateProgress(2, 'active');
                console.log('Starting enhanced API request with error handling...');
                
                // Enhanced fetch with timeout and retry logic
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000); // 60 second timeout
                
                const response = await fetch(`/agent/chat/${currentSessionId}`, {
                    method: 'POST',
                    body: formData,
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    if (response.status === 429) {
                        throw new Error('Rate limit exceeded. Please wait a moment and try again.');
                    } else if (response.status >= 500) {
                        throw new Error(`Server error (${response.status}). The service is experiencing issues.`);
                    } else if (response.status === 401 || response.status === 403) {
                        throw new Error('Authentication failed. The service is temporarily unavailable.');
                    } else {
                        throw new Error(`Request failed with status ${response.status}`);
                    }
                }
                
                // Move to AI thinking step
                updateProgress(2, 'completed');
                updateProgress(3, 'active');
                console.log('Transcription completed, AI processing...');
                
                const result = await response.json();
                console.log('Enhanced API Response:', result);
                
                // Process the response and check for errors/fallbacks
                if (!processApiResponse(result, 'conversation processing')) {
                    return;
                }
                
                // Move to voice generation step
                updateProgress(3, 'completed');
                updateProgress(4, 'active');
                console.log('AI processing completed, generating voice...');
                
                if (result.transcribed_text && result.llm_response) {
                    console.log('Adding to conversation history:', {
                        user: result.transcribed_text,
                        assistant: result.llm_response
                    });
                    
                    // Add to conversation history
                    conversationHistory.push({
                        role: 'user',
                        content: result.transcribed_text
                    });
                    conversationHistory.push({
                        role: 'assistant',
                        content: result.llm_response
                    });
                    
                    console.log('Conversation history after update:', conversationHistory);
                    
                    messageCount += 2;
                    displayConversation();
                    saveConversation();
                    updateMessageLimit();
                    
                    // Small delay before completing voice generation
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                    // Complete voice generation step
                    updateProgress(4, 'completed');
                    console.log('Voice generation completed');
                    
                    // Enhanced audio handling with fallback detection
                    console.log('Checking for audio URL in response:', result.audio_url);
                    if (result.audio_url) {
                        console.log('Audio URL found, attempting enhanced autoplay:', result.audio_url);
                        
                        // Check if this is fallback audio
                        const isFallbackAudio = result.voice && result.voice.includes('fallback');
                        
                        // Always add a permanent replay button first
                        addPermanentReplayButton(result.audio_url, isFallbackAudio);
                        
                        // Enhanced audio playback with error handling
                        await playAudioWithFallback(result.audio_url, isFallbackAudio);
                        
                    } else {
                        console.log('No audio URL found in response');
                        showError(
                            'Audio generation failed', 
                            'Voice synthesis is temporarily unavailable', 
                            'warning'
                        );
                    }
                } else {
                    console.error('Missing transcribed_text or llm_response in result');
                    showError(
                        'Incomplete response', 
                        'The server returned an incomplete response. Please try again.', 
                        'error', 
                        true
                    );
                }
                
                // Reset retry count on success
                errorRetryCount = 0;
                lastFailedAction = null;
                
            } catch (error) {
                console.error('Error processing conversation:', error);
                
                // Enhanced error handling based on error type
                if (error.name === 'AbortError') {
                    updateProgress(2, 'error');
                    handleApiError(new Error('Request timed out. Please try with a shorter message.'), 'conversation timeout');
                } else if (error.message.includes('fetch')) {
                    updateProgress(2, 'error');
                    handleApiError(new Error('Network connection failed. Please check your internet connection.'), 'network error');
                } else {
                    updateProgress(2, 'error');
                    handleApiError(error, 'conversation processing');
                }
                
                // Reset progress on error
                hideProgress();
            } finally {
                // Hide progress after a delay
                setTimeout(() => {
                    hideProgress();
                }, 1000);
                document.getElementById('recordingStatus').textContent = 'Click to start talking';
            }
        }
        
        async function playAudioWithFallback(audioUrl, isFallbackAudio = false) {
            try {
                // Create multiple audio objects and try different approaches
                if (currentAudio) {
                    currentAudio.pause();
                }
                
                // Primary audio object
                currentAudio = new Audio(audioUrl);
                
                // Set audio properties for better autoplay compatibility
                currentAudio.preload = 'auto';
                currentAudio.autoplay = true;
                currentAudio.volume = 1.0;
                
                console.log('Enhanced audio object created with fallback handling');
                
                // Enhanced audio event handlers
                currentAudio.onloadeddata = () => {
                    console.log('Audio loaded successfully, attempting play');
                    currentAudio.play().catch(e => console.log('Initial play failed:', e));
                };
                
                currentAudio.oncanplaythrough = () => {
                    console.log('Audio can play through, attempting play');
                    currentAudio.play().catch(e => console.log('CanPlayThrough play failed:', e));
                };
                
                currentAudio.onended = () => {
                    console.log('Audio playback finished');
                };
                
                currentAudio.onerror = (e) => {
                    console.error('Audio playback error:', e);
                    if (!isFallbackAudio) {
                        showError(
                            'Audio playback failed',
                            'There was an issue playing the voice response. You can still read the text response above.',
                            'warning'
                        );
                    }
                };
                
                // Multiple enhanced play attempts with different timing
                console.log('Starting enhanced autoplay attempts...');
                
                // Attempt 1: Immediate
                currentAudio.play()
                    .then(() => {
                        console.log('‚úÖ Enhanced autoplay attempt 1 SUCCESS');
                    })
                    .catch(e => {
                        console.log('‚ùå Enhanced autoplay attempt 1 failed:', e);
                        
                        // Attempt 2: After small delay
                        setTimeout(() => {
                            currentAudio.play()
                                .then(() => {
                                    console.log('‚úÖ Enhanced autoplay attempt 2 SUCCESS (delayed)');
                                })
                                .catch(e => {
                                    console.log('‚ùå Enhanced autoplay attempt 2 failed:', e);
                                    
                                    // Attempt 3: Force play with user gesture simulation
                                    setTimeout(() => {
                                        console.log('Attempting enhanced force play...');
                                        currentAudio.muted = false;
                                        currentAudio.volume = 1.0;
                                        currentAudio.currentTime = 0;
                                        currentAudio.play()
                                            .then(() => {
                                                console.log('‚úÖ Enhanced autoplay attempt 3 SUCCESS (forced)');
                                            })
                                            .catch(e => {
                                                console.log('‚ùå All enhanced autoplay attempts failed:', e);
                                                // Flash the replay button to get user attention
                                                flashReplayButton();
                                                
                                                if (!isFallbackAudio) {
                                                    showError(
                                                        'Click to play audio',
                                                        'Automatic audio playback was blocked. Please click the play button below.',
                                                        'info'
                                                    );
                                                }
                                            });
                                    }, 100);
                                });
                        }, 200);
                    });
                
                // Additional aggressive attempt after page interaction
                document.addEventListener('click', function autoplayOnClick() {
                    console.log('Page clicked, attempting enhanced autoplay...');
                    if (currentAudio && currentAudio.paused) {
                        currentAudio.play()
                            .then(() => {
                                console.log('‚úÖ Enhanced autoplay after click SUCCESS');
                                document.removeEventListener('click', autoplayOnClick);
                            })
                            .catch(e => {
                                console.log('‚ùå Enhanced autoplay after click failed:', e);
                            });
                    }
                }, { once: true });
                
            } catch (error) {
                console.error('Enhanced audio playback setup failed:', error);
                showError(
                    'Audio setup failed',
                    'There was an issue setting up audio playback. The text response is still available above.',
                    'warning'
                );
            }
        }
        
        function addPermanentReplayButton(audioUrl, isFallbackAudio = false) {
            console.log('Adding enhanced permanent replay button for:', audioUrl);
            
            // Create a container for the audio controls
            const audioContainer = document.createElement('div');
            audioContainer.style.cssText = 'margin: 12px 0; padding: 12px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;';
            audioContainer.id = 'audio-container-' + Date.now(); // Add unique ID for flashing
            
            // Add fallback indicator if needed
            if (isFallbackAudio) {
                const fallbackIndicator = document.createElement('div');
                fallbackIndicator.className = 'fallback-audio-indicator';
                fallbackIndicator.innerHTML = '<span class="icon">‚ö†Ô∏è</span> Using backup audio system';
                audioContainer.appendChild(fallbackIndicator);
            }
            
            // Create the replay button
            const replayButton = document.createElement('button');
            replayButton.textContent = 'üîä Play AI Response';
            replayButton.style.cssText = 'padding: 8px 16px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; margin-right: 8px; font-size: 14px;';
            replayButton.id = 'replay-btn-' + Date.now(); // Add unique ID for flashing
            
            // Create a status indicator
            const statusIndicator = document.createElement('span');
            statusIndicator.textContent = 'Ready to play';
            statusIndicator.style.cssText = 'font-size: 12px; color: #6b7280; margin-left: 8px;';
            
            // Create a new audio object for this specific response
            const replayAudio = new Audio(audioUrl);
            
            // Enhanced audio event handlers
            replayAudio.onloadstart = () => {
                statusIndicator.textContent = 'Loading...';
                statusIndicator.style.color = '#3b82f6';
            };
            
            replayAudio.oncanplaythrough = () => {
                statusIndicator.textContent = 'Ready to play';
                statusIndicator.style.color = '#10b981';
            };
            
            replayAudio.onplay = () => {
                replayButton.textContent = '‚è∏Ô∏è Pause';
                replayButton.style.background = '#f59e0b';
                statusIndicator.textContent = 'Playing...';
                statusIndicator.style.color = '#10b981';
            };
            
            replayAudio.onpause = () => {
                replayButton.textContent = 'üîä Play AI Response';
                replayButton.style.background = '#10b981';
                statusIndicator.textContent = 'Paused';
                statusIndicator.style.color = '#6b7280';
            };
            
            replayAudio.onended = () => {
                replayButton.textContent = 'üîÑ Replay';
                replayButton.style.background = '#6366f1';
                statusIndicator.textContent = 'Finished - Click to replay';
                statusIndicator.style.color = '#6366f1';
            };
            
            replayAudio.onerror = () => {
                replayButton.textContent = '‚ùå Audio Error';
                replayButton.style.background = '#ef4444';
                replayButton.disabled = true;
                statusIndicator.textContent = 'Failed to load audio';
                statusIndicator.style.color = '#ef4444';
                
                if (!isFallbackAudio) {
                    showError(
                        'Audio playback error',
                        'This audio file could not be played. This may be due to network issues or audio format problems.',
                        'warning'
                    );
                }
            };
            
            // Enhanced button click handler
            replayButton.onclick = () => {
                console.log('Enhanced replay button clicked, audio paused:', replayAudio.paused);
                
                try {
                    if (replayAudio.paused) {
                        // Reset to beginning if audio has ended
                        if (replayAudio.ended) {
                            replayAudio.currentTime = 0;
                        }
                        
                        replayAudio.play()
                            .then(() => {
                                console.log('Enhanced replay audio started successfully');
                            })
                            .catch(e => {
                                console.error('Enhanced replay audio failed:', e);
                                replayButton.textContent = '‚ùå Play Failed';
                                replayButton.style.background = '#ef4444';
                                statusIndicator.textContent = 'Playback failed';
                                statusIndicator.style.color = '#ef4444';
                                
                                showError(
                                    'Audio playback failed',
                                    'Unable to play this audio. This may be due to browser restrictions or network issues.',
                                    'warning'
                                );
                            });
                    } else {
                        replayAudio.pause();
                    }
                } catch (error) {
                    console.error('Replay button error:', error);
                    showError(
                        'Audio control error',
                        'There was an issue with the audio controls.',
                        'warning'
                    );
                }
            };
            
            // Assemble the container
            audioContainer.appendChild(replayButton);
            audioContainer.appendChild(statusIndicator);
            
            // Add to the chat area
            const chatContainer = document.getElementById('chatMessages');
            chatContainer.appendChild(audioContainer);
            
            // Scroll to show the new button
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            // Store reference for flashing
            window.latestReplayButton = replayButton;
            window.latestAudioContainer = audioContainer;
            
            console.log('Enhanced permanent replay button added successfully');
        }
        
        // Enhanced error testing function
        async function testErrorHandling() {
            console.log('Testing error handling scenarios');
            hideError();
            
            const errorTypes = ['stt', 'llm', 'tts', 'all'];
            const selectedError = errorTypes[Math.floor(Math.random() * errorTypes.length)];
            
            showError(
                'Testing error scenarios',
                `Simulating ${selectedError} service failure to test error handling...`,
                'info'
            );
            
            try {
                const response = await fetch(`/agent/chat/${currentSessionId}/test-errors?error_type=${selectedError}`, {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    throw new Error(`Test request failed: ${response.status}`);
                }
                
                const result = await response.json();
                console.log('Error test result:', result);
                
                if (processApiResponse(result, 'error testing')) {
                    // Add the test response to conversation
                    if (result.transcribed_text && result.llm_response) {
                        conversationHistory.push({
                            role: 'user',
                            content: result.transcribed_text
                        });
                        conversationHistory.push({
                            role: 'assistant',
                            content: result.llm_response
                        });
                        
                        messageCount += 2;
                        displayConversation();
                        saveConversation();
                        updateMessageLimit();
                        
                        // Add replay button for test audio
                        if (result.audio_url) {
                            addPermanentReplayButton(result.audio_url, true);
                        }
                    }
                }
                
            } catch (error) {
                console.error('Error testing failed:', error);
                handleApiError(error, 'error testing');
            }
        }
        
        function flashReplayButton() {
            console.log('Flashing replay button to get user attention');
            if (window.latestReplayButton && window.latestAudioContainer) {
                const button = window.latestReplayButton;
                const container = window.latestAudioContainer;
                
                // Flash animation
                let flashCount = 0;
                const flashInterval = setInterval(() => {
                    if (flashCount < 6) { // Flash 3 times
                        if (flashCount % 2 === 0) {
                            button.style.background = '#ef4444';
                            button.style.transform = 'scale(1.1)';
                            container.style.background = '#fef2f2';
                            container.style.borderColor = '#ef4444';
                        } else {
                            button.style.background = '#10b981';
                            button.style.transform = 'scale(1)';
                            container.style.background = '#f8fafc';
                            container.style.borderColor = '#e2e8f0';
                        }
                        flashCount++;
                    } else {
                        clearInterval(flashInterval);
                        // Reset to normal
                        button.style.background = '#10b981';
                        button.style.transform = 'scale(1)';
                        container.style.background = '#f8fafc';
                        container.style.borderColor = '#e2e8f0';
                    }
                }, 300);
            }
        }
        
        function showProgress() {
            document.getElementById('progressIndicator').style.display = 'block';
            resetProgress();
        }
        
        function hideProgress() {
            document.getElementById('progressIndicator').style.display = 'none';
        }
        
        function resetProgress() {
            for (let i = 1; i <= 4; i++) {
                const step = document.getElementById(`step${i}`);
                step.classList.remove('active', 'completed');
            }
        }
        
        function updateProgress(stepNumber, status) {
            const step = document.getElementById(`step${stepNumber}`);
            step.classList.remove('active', 'completed');
            if (status) {
                step.classList.add(status);
            }
        }
        
        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            sidebar.classList.toggle('open');
        }
        
        // Mobile responsiveness
        if (window.innerWidth <= 768) {
            document.querySelector('.sidebar-toggle').style.display = 'block';
        }
        
        function testDisplay() {
            console.log('Test button clicked');
            console.log('Current conversationHistory:', conversationHistory);
            console.log('Current messageCount:', messageCount);
            
            // Add a test message
            conversationHistory.push({
                role: 'user',
                content: 'Test user message'
            });
            conversationHistory.push({
                role: 'assistant',
                content: 'Test AI response - this is a sample response to verify the display is working.'
            });
            
            console.log('Added test messages, calling displayConversation');
            displayConversation();
            
            // Test audio playback with a simple beep
            console.log('Testing audio playback...');
            const testAudio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBTuW2e/LdCUELIHQ8tiJOQcZZ7zl559NEApPqOPxtmMcBQeA5');
            testAudio.play()
                .then(() => console.log('Test audio played successfully'))
                .catch(e => console.error('Test audio failed:', e));
        }
        
        // Animation for loading dots
        const style = document.createElement('style');
        style.textContent = `
            @keyframes bounce {
                0%, 80%, 100% { transform: translateY(0); }
                40% { transform: translateY(-10px); }
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>
